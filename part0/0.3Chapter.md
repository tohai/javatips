# Chương 4: Vấn đề giá biên và null

## 4.1 Vấn đề về giá trị biên

Sau một thời gian làm trong nghề tôi nhận ra rằng nguwoif mới thường quan tâm vào thẳng nghiệp vụ code mà công để ý các tiểu tiết. Tôi cũng đã từng như vậy. Họ không quan tâm đến các giá trị biên và null.

Hãy xem xet việc insert/update vào bảng product trong Database
xem ví dụ dưới đây

```java
    ....
    updateProduct(productKey, productName);
    .....
    private void updateProduct(Long productKey,String productName){
        Product product = new Product();
        product.setProductKey(productKey);
        product.setProductName(productName);
        productDao.updateProductNameByID(product);
    } 
```

Nhìn trên code ta có thể thấy rõ ràng là hàm updateProduct đã yêu cầu đầu vào đã validate productName (max size, min size, format ...).

tuy nhiên đa phần người mới vào nghề thường không validation productName trước khi gọi hàm này. Theo như một số ống lí luận là "**nó sẽ ném ra một exception và tôi sẽ bắt và xử lý nó**". Vâng nó đúng là trả ra một exception. Nhưng nếu khách hàng yêu cầu đưa ra lỗi cụ thể -> khi đó sẽ làm sao ? quay về bài toán validate hay là bài toán đọc nó trong exception khó gặp -> và ở đây xác định là quay về bài toán validation :). đôi khi code có thể dài hơn tuy nhiên tính toán đến khả năng mở rộng của nó là điều cực kì quan trọng.

Còn có các vấn đề liên quan đến limit default. tôi sẽ không đề cập ở đây.

## 4.2 vấn đề về null

### Ví dụ 1

```java
    boolean stringeq = productName.equals("Haitv");
```

Đánh giá code nếu dựa vào dòng code trên ta có thể thấy được lỗi tiềm ẩn như sau:\
productName = null thì đoạn code trên sẽ gây lỗi

cách sửa cũng đơn giản thôi hay đổi thứ tự so sánh như code dưới

```java
    boolean stringEq = "Haitv".equals(productName);
```

Như vậy lỗi tiềm ẩn trên đã được giải quyết.

Vậy nếu như đoạn code dưới thì sao

```java
    boolean stringEq = name.equals(productName);
```

Nhận thấy rằng không có cơ sở gì để đảm bảo được biến `name`, `productName` sẽ không mang giá trị `null`

Vậy trong trường hợp này ta sẽ xử lý như thế nào.

Đầu tiên hãy tìm trong common function đã tồn tại code thay thế nó hay chưa. Nếu đã có thì dùng thôi

Nếu trong code common không có hãy kiểm tra xem các thư viện bạn dùng có hỗ trợ hàm này không. ví dụ như common.lang của apache,.. nếu đã có thì lôi chugs ra dùng (phần này có thể sẽ hơi khó đối với những người chưa làm nhiều với thư viện hoặc mới vào nghề).

Trường hợp còn lại, Nên viết hàm này thành code common để dùng cho các lần sau

### Ví dụ 2

```java
    @Autowire
    ProductService productService;
    ...
    List<String> products = productService.getProducts();
    products.forEach(System.out::println);
```

`ProductService` là một interface và nó hoàn toàn bị giấu đi nội dung implement của nó.

Ta sẽ phân tích và đánh giá đoạn code trên như sau:\
Sẽ ra sao nếu `products` = null -> `products.forEach` sẽ gây ra NullpoiterException lỗi rất nhiều người gặp phải. Đây là code có nguy cơ gặp lỗi nếu như không xác định được kết quả trả về của getProducts().

Vậy bạn sẽ làm sao để xử lý với trường hợp này?\
Check null trước khi cho vào foreach?\
Hay hay quy ước rằng những function mà bạn tả vè kiểu Collection thì mặc nhiên không trả null.

**`Hạn chế tối đa việc trả ra null hoặc truyền các tham số là null nếu không thực sự cần thiết`**. \
Tin tôi đi điều này sẽ làm giảm rất nhiều bug phát sinh do null.

## 4.3 tổng kết

trong chương này ta cần lưu ý một só vấn đề về biên cũng như một số vấn đề về null như sau:

1. Hãy xử lý biên và luôn quan tâm đến việc có khả năng mở rộng nó sau này.
2. hạn chế tối đa việc trả ra null hoặc truyền các tham số là null nếu không thực sự cần thiết