# Chương 14 Bàn luận về lớp lồng nhau - Nested Classes

Một khía cạnh của ngôn ngữ Java không được hiểu rộng rãi là khái niệm về các lớp lồng nhau. Các lớp này cho phép bạn giới hạn toàn bộ một lớp trong một phạm vi giới hạn của một lớp hoặc phương thức khác. Khái niệm lồng một lớp trong một lớp hoặc phương thức khác đưa ra các vấn đề độc nhất không tìm thấy ở nơi khác trong lập trình hướng đối tượng. Không phải tất cả các loại lớp lồng nhau đều nên được sử dụng thường xuyên, vì vậy bạn có thể sẽ gặp hầu hết chúng trong mã của người khác. Do đó, điều quan trọng là bạn phải hiểu cách hoạt động của các lớp lồng nhau khác nhau.

Các lớp lồng nhau thuộc một trong ba loại cơ bản:

- Các lớp bên trong (Inner classes)
- Các lớp bên trong phạm vi giới hạn (Limited-scope inner classes)
- Các lớp lồng nhau tĩnh (Static nested classes)

Mỗi danh mục này có các quy tắc truy cập và cách sử dụng riêng.

## 14.1 Các lớp bên trong (Inner classes)

Đầu tiên tôi sẽ đưa ra 2 ví dụ nói về phạm vi của Inner classes:

ví dụ 1:

```java
public class InnerClassDemo extends JDialog {

  private static final String LOGO = "LOGO";
	private int beepCount = 0;

  public InnerClassDemo(final int beepCount) {
    super( );
    setTitle("Anonymous Demo");
    contentPane = getContentPane( );
    contentPane.setLayout(new BorderLayout( ));
    JLabel logoLabel = new JLabel(LOGO);
    contentPane.add(BorderLayout.NORTH, logoLabel);
    JButton btn = new BeepButton("Beep");
    contentPane.add(BorderLayout.SOUTH, btn);
    pack( );
    this.beepCount = beepCount;
  }

  private class BeepButton extends JButton implements ActionListener {
    public BeepButton(final String text) {
      super(text);
      addActionListener(this);
    }

    public void actionPerformed(final ActionEvent event) {
      try {
        for(int count = 0; count < beepCount; count++) {
          Toolkit.getDefaultToolkit().beep( );
          Thread.sleep(100);
        }
      } catch (final InterruptedException ex) {
        throw new RuntimeException(ex);
      }
    }
  }
}
```

lớp BeepButton là một lớp trong của InnerClassDemo. bạn có thể thấy được trong lớp BeepButton cụ thể là function actionPerformed nó đã dùng một biến beepCount mặc dù nó không khai báo ở trong function này. Ở đây tôi muốn nhấn mạnh một điều là Inner class được coi là một thành phần của class và nó có quyền được truy cập đến tất cả các thành phần trong lớp bao của nó.

Thêm một chú ý nữa là BeepButton được khai báo private nên phạm vi của nó chỉ hoạt động bên trong lớp InnerClassDemo. và ta không thể khai báo nó bên ngoài lớp.

Vậy nếu như đổi private thành public thì sao. Đây là nguyên nhân để tôi đưa ra ví dụ thứ 2:

```java
public class MonitorScreen {

	public class PixelPoint {

		private int x;
		private int y;

		public PixelPoint(final int x, final int y) {
			this.x = x;
			this.y = y;
		}

		public int getX() {
			return x;
		}

		public int getY() {
			return y;
		}
	}
}
```

vậy phái bên ngoài lớp MonitorScreen bạn tạo một instance PixelPoint như thế nào

```java
MonitorScreen.PixelPoint obj = new MonitorScreen.PixelPoint();
```

Lệnh này sẽ bị lỗi ngay lập tức. ở đây muốn tạo một instance PixelPoint bạn bắt buộc phải tạo một instance MonitorScreen trước và đại loại trông nó như thế này:

```java
MonitorScreen screen = new MonitorScreen();
MonitorScreen.PixelPoint pixel = screen.new PixelPoint(25, 40);
System.out.println(pixel.getX());
System.out.println(pixel.getY());
```

nhìn kỹ lại **`screen.new PixelPoint(25, 40);`** bạn ko nhìn nhầm đâu. nó thực sự kì lạ có gì đó sai sai. thực tế là code đúng đấy. Tuy nhiên nó lại vi phạm vào nguyên tắc lập trình hướng đối tượng vài vậy tôi không khuyến khích bạn dùng public cho một class bên trong một class khác.

### 14.1.2 Cấu trúc phân cấp của các lớp bên trong

Xem ví dụ dưới đây

```java
public abstract class BasicMonitorScreen {

  private Dimension resolution;

  public BasicMonitorScreen(final Dimension resolution) {
    this.resolution = resolution;
  }

  public Dimension getResolution( ) {
    return this.resolution;
  }

  protected abstract class PixelPoint {
    private int x;
    private int y;

    public PixelPoint(final int x, final int y) {
      this.x = x;
      this.y = y;
    }

    public int getX( ) {
      return x;
    }

    public int getY( ) {
      return y;
    }
  }
}
```

Ở đây lớp bao là một lớp trừu tượng và lóp bên trong PixelPoint có thể là một lớp cụ thể hoặc một lớp trừu tượng. Tuy nhiên, trong trường hợp lớp trong là một lớp trừ tượng thì `hãy đảm bảo rằng một lớp bên trong trừu tượng không làm cho lớp bao quanh trở nên trừu tượng, như với một phương thức trừu tượng`.

dưới đây tôi sẽ cung cấp ví dụ về việc mở rộng trên lớp cơ sở trừ tượng

```java
public class ColorMonitorScreen extends BasicMonitorScreen {

	public ColorMonitorScreen(Dimension resolution) {
		super(resolution);
	}

	protected class ColorPixelPoint extends PixelPoint {

		private Color color;

		public ColorPixelPoint(final int x, final int y, final Color color) {
			super(x, y);
			this.color = color;
		}

		public Color getColor() {
			return this.color;
		}
	}
}
```

Tạo các lớp cụ thể trong một lớp cơ sở trừu tượng là một cách tốt để mô hình hóa các mối quan hệ thành phần trong một hệ thống phân cấp kế thừa. Bạn có thể khai báo các lớp đã soạn trong lớp cơ sở và cho phép các lớp con sử dụng lớp đã soạn đó.

Lớp bên trong có thể là một lóp public tuy nhiên tôi không khuyến khích điều này đó là một ý tưởng tồi.

## 14.2 Các lớp bên trong phạm vi giới hạn (Limited-scope inner classes)

Một trong những kiểu lớp bên trong kỳ lạ nhất là lớp bên trong có phạm vi giới hạn. Các lớp có phạm vi giới hạn được xác định phạm vi cho một khối mã cụ thể. Việc khai báo và sử dụng chúng đều diễn ra trong khối đó. Để hiểu rõ hơn về cách hoạt động của các lớp bên trong có phạm vi giới hạn.

Xem ví dụ dưới đây:

```java
public class MethodInnerClassDemo extends JDialog {

	private static final String LOGO_LOCATION = "oreilly/hcj/nested/oreilly_header3.gif";
	private static final ImageIcon LOGO;

	static {

		LOGO = new ImageIcon(ClassLoader.getSystemClassLoader().getResource(LOGO_LOCATION));

	}

	private final Container contentPane;

	private String demo;

	public MethodInnerClassDemo(final int value) {
		super();
		String title = "Inner Class Demo";
		setTitle(title);
		setModal(true);

		contentPane = getContentPane();
		contentPane.setLayout(new BorderLayout());
		JLabel logoLabel = new JLabel(LOGO);
		contentPane.add(BorderLayout.NORTH, logoLabel);
		JButton btn = new JButton("Beep");

		class MyActionListener implements ActionListener {

			public void actionPerformed(final ActionEvent event) {

				Toolkit.getDefaultToolkit().beep();
				System.out.println(value);
				System.out.println(LOGO_LOCATION);
				System.out.println(MethodInnerClassDemo.this.demo);

			}

		}

		btn.addActionListener(new MyActionListener());
		contentPane.add(BorderLayout.SOUTH, btn);
		pack();
	}
}
```

hay để ý các biến của lớp bao ngoài hoặc hàm bao ngoài là biến final thì nó có thể truy cập một cách trực tiếp từ lớp bên trong. Trong trường hợp biến demo thì nó được truy cập như lện dưới

**`System.out.println(MethodInnerClassDemo.this.demo);`**

hay để ý biến `title` tuy nó nằm trong hàm MethodInnerClassDemo tuy nhiên nó sẽ không thể truy cập được nếu nó không phải là một biến final. 

tôi sẽ lấy một ví dụ để nói về phạm vi của các lóp bên trong. Xem ví dụ dưới:

```java
public class MethodInnerClassDemo extends JDialog {

	private static final ImageIcon LOGO;
	private static final String LOGO_LOCATION = "oreilly/hcj/nested/oreilly_header3.gif";
	static {
		LOGO = new ImageIcon(ClassLoader.getSystemClassLoader().getResource(LOGO_LOCATION));
	}
	private final Container contentPane;
	private String demo;

	public MethodInnerClassDemo(final int value) {
		super();
		String title = "Inner Class Demo";
		setTitle(title);
		setModal(true);
		contentPane = getContentPane();
		contentPane.setLayout(new BorderLayout());
		JLabel logoLabel = new JLabel(LOGO);
		contentPane.add(BorderLayout.NORTH, logoLabel);
		JButton btn = new JButton("Beep");

		class MyActionListener implements ActionListener {
			public void actionPerformed(final ActionEvent event) {
				Toolkit.getDefaultToolkit().beep();
				System.out.println(value);
				System.out.println(LOGO_LOCATION);
				System.out.println(MethodInnerClassDemo.this.demo);
				// System.out.println(title); // <= compiler error
			}
		}
		btn.addActionListener(new MyActionListener());
		contentPane.add(BorderLayout.SOUTH, btn);
		pack();
	}

	public MethodInnerClassDemo() {
		super();
		setTitle("Inner Class Demo");
		setModal(true);
		contentPane = getContentPane();
		contentPane.setLayout(new BorderLayout());
		JLabel logoLabel = new JLabel(LOGO);
		contentPane.add(BorderLayout.NORTH, logoLabel);
		JButton btn1 = new JButton("Beep");
		JButton btn2 = new JButton("Bell");

		class MyActionListener implements ActionListener {
			public void actionPerformed(final ActionEvent event) {
				Toolkit.getDefaultToolkit().beep();
			}
		}
		btn1.addActionListener(new MyActionListener());
		btn2.addActionListener(new MyActionListener());
		JPanel pnl = new JPanel(new GridLayout(1, 2));
		pnl.add(btn1);
		pnl.add(btn2);
		contentPane.add(BorderLayout.SOUTH, pnl);
		pack();
	}

	public void someMethod() {
		ActionListener listener = new MyActionListener(); // <= compiler error.
	}

}
```

Ở đây bạn nhìn thấy là có 2 lớp MyActionListener khác nhau nhưng cũng tên được đặt trong 2 function khác nhau. và nó hoàn toàn không có vấn đề gì cả. Ở đây tôi muons ám chỉ việc bạn có thể khai báo nó trong một hàm và lớp khai báo đó chỉ có tác dụng trong một hàm nó không được tính vào thành phần của lớp bao. Như trong someMethod nó sẽ báo một lỗi compiler và nó không biết MyActionListener là thằng nào cả.

Ở đây bạn có thể bao phạm vi của nó ở trong một cặp dấu ngoặc nhọn '{' '}' để thể hiện phạm vi của chúng.

Trên thực tế thì người ta sử dụng một loại lớp bên trong phạm vi giới hạn cụ thể, lớp này chỉ áp dụng cho một lệnh gọi hoặc phép gán phương thức cụ thể. chúng được gọi là một lớp ẩn danh.

### 14.2.1 Lớp ẩn danh (Anonymous Classes)

Khái niệm về các lớp ẩn danh thường gây nhầm lẫn cho các nhà phát triển Java. Về cơ bản, các lớp ẩn danh là các lớp có phạm vi giới hạn được khai báo nhưng không được lập trình viên đặt tên (do đó được chỉ định là "vô danh") và chỉ có tuổi thọ giới hạn. Mặc dù chúng có thể được sử dụng cho nhiều ứng dụng khác nhau, chúng thường được sử dụng nhất làm trình xử lý sự kiện trong các chương trình GUI.

Xem ví dụ dưới:

```java
public AnonymousDemo() {
		super();
		setTitle("Anonymous Demo");
		setModal(true);
		contentPane = getContentPane();
		contentPane.setLayout(new BorderLayout());
		JLabel logoLabel = new JLabel(LOGO);
		contentPane.add(BorderLayout.NORTH, logoLabel);
		JButton btn = new JButton("Beep");

		btn.addActionListener(new ActionListener() {
			public void actionPerformed(final ActionEvent event) {
				Toolkit.getDefaultToolkit().beep();
			}
		});

		contentPane.add(BorderLayout.SOUTH, btn);
		pack();
}
```

lớp ẩn danh cso thể sử dụng cho bất cứ lớp nào không phải final.

Một điểm khác biệt giữa các lớp ẩn danh và các lớp có phạm vi giới hạn là các lớp ẩn danh không thể sử dụng các từ khóa abtract hoặc final. trên thực tế thì mọi lớp ẩn danh được coi là final. và một điều nữa là lớp ẩn danh này không có tên nên bạn không thể khai báo phân cấp của các lớp ẩn danh.

Không thể khai báo một contructor trong một lớp ẩn danh và bạn cũng chẳng thể làm được việc đó vì nó ko có tên.

trên thưc tế nói no ko có tên không phải là đúng. Nó có tên nhưng cái tên đó lập trình viên không thể dùng được. máy ảo JVM sẽ biên dịch nó thành các class như bình thường và nó sẽ được mang theo số thứ tự mà follow code gặp phải.

### 14.2.2 Các vấn đề Limited-Scope Inner Classes

Vì cú pháp của các lớp ẩn danh không được coi là cú pháp Java chính thống, các lớp ẩn danh rất khó đọc và thường bị hiểu nhầm. Hơn nữa, chúng có xu hướng bị lạm dụng, đặc biệt là trong code GUI.

Xem ví dụ dưới:

```java
public class AnonymousDemo extends JDialog {
  public AnonymousDemo(final int exitDelay) {
    super( );
    setTitle("Anonymous Demo");
    setModal(true);
    contentPane = getContentPane( );
    contentPane.setLayout(new BorderLayout( ));
    final String delayDisplay = new Object( ) {
          public String toString( ) {
            System.out.println(demo);
            if ((exitDelay) > 1000) {
              NumberFormat formatter = NumberFormat.getNumberInstance( );
              formatter.setMinimumFractionDigits(2);
              double time = exitDelay / 1000.0;
              return (new String(formatter.format(time) + " seconds"));
            } else {
              return new String(exitDelay + " microseconds");
            }
          }
        }.toString( );
    addWindowListener(new WindowAdapter( ) {
        public void windowClosing(final WindowEvent event) {
          try {
            System.out.println("Waiting for " + delayDisplay);
            Thread.sleep(exitDelay);
          } catch (final InterruptedException ex) {
            throw new RuntimeException(ex);
          }
        }
      });

    JLabel logoLabel = new JLabel(LOGO);
    contentPane.add(BorderLayout.NORTH, logoLabel);
    JButton btn = new JButton("Beep") {
        public void fireActionPerformed(final ActionEvent event) {
          if (LOGGER.isDebugEnabled( )) {
            LOGGER.debug(event);
            LOGGER.debug("This class is: " + this.getClass( ).getName( ));
          }
          super.fireActionPerformed(event);
        }
      };

    btn.addActionListener(new ActionListener( ) {
        public void actionPerformed(final ActionEvent event) {
          doBeep( );
        }
      });

    contentPane.add(BorderLayout.SOUTH, btn);
    pack( );
  }
}
```

Nhìn code trên bạn có dám chắc rằng rõ ràng? và bạn có thể hiểu nó ngay lập tức? ( à vẫn có - trừ khi bạn là nguwoif code ra nó :V). Ở đây người code đã quá lạm dụng lớp ản danh để code. Hãy nhớ rằng lớp ẩn danh không được coi là cú pháp Java chính thống.

Thay vào đó có thể thay bằng lời gọi phương thức và thực hiện các triển khai giao điện . Code sẽ dài hơn nhưng đổi lại ta được tính rõ ràng, khẳ năng mở rộng, khả năng bảo trì ...

Ngoài ra, các lớp ẩn danh hoàn toàn không thể sử dụng lại được. Điều này đi ngược lại lý do tại sao bạn khai báo một lớp ngay từ đầu. Cốt lõi của lập trình hướng đối tượng là khả năng tái sử dụng; do đó, việc khai báo một lớp không thể sử dụng vi phạm các nguyên tắc của kỹ thuật hướng đối tượng.

Cuối cùng, ẩn danh và các lớp bên trong có phạm vi giới hạn khác làm cho mã gỡ lỗi trở nên khó khăn và khó hiểu. Bạn có thể đang lướt qua mã bằng trình gỡ lỗi và đột nhiên được chuyển đến một đoạn mã ở giữa một phương thức. Nó sẽ đòi hỏi sự tập trung và nhận thức về mã để nhận ra rằng bạn đang ở trong một khai báo lớp. Ngoài ra, vì các lớp ẩn danh không có tên mà lập trình viên có thể truy cập, các lỗi xảy ra trong lớp đó thường rất khó xác định.

Tất cả những vấn đề này làm cho các lớp bên trong có phạm vi giới hạn trở thành vấn đề. Vì vậy, tôi khuyên bạn nên tránh chúng bất cứ khi nào có thể. Tuy nhiên, bây giờ bạn nên chuẩn bị sẵn sàng khi bạn gặp chúng trong code của người khác. Nếu bạn có cơ hội, tôi khuyên bạn nên chuyển đổi code của họ để sử dụng các kỹ thuật khác thay thế.

## 14.3 Lớp lồng Static (Static nested classes)

Nhiều người đã lầm tưởng rằng lớp lồng static là một loại inner class thực tế đây là một quan điểm sai lầm. hãy xem ví dụ dưới đây :

```java
public class OuterClass {
	private static final String name = "Robert";
	private static String company = "O'Reilly";
	private int value = 5;

	public static class SomeClass {
		public void someMethod() {
			System.out.println(company);
			System.out.println(name);
			System.out.println(value); // <= Compiler error
		}
	}
}
```

Trong ví dụ này. bạn có thể truy cập được biến static và biến final tuy nhiên bạn không thể truy cập đến biến value bằng cách truy cập trực tiếp hoặc giống như inner kiểu như class  `OuterClass.this.value`. Nó đều không có tác dụng.

Tiếp đó là phàn khi sử dụng, xem ví dụ dưới:

```java
public static void main(final String[] args) {
    OuterClass.SomeClass obj = new OuterClass.SomeClass( );
    obj.someMethod( );
  }
```

Đem so sánh vói public inner class thì thg này có vể dễ dùng hơn và nó cũng dễ được chấp thuận hơn vì cú pháp java vẫn còn.